%
% Category theory (arrows only).
%

assign(max_megs, 2000).
op(601, infix_left,        "*" ).


formulas(assumptions).
% E means undefined --------------
E = 0.
all f (E*f = E).
all f (f*E = E).
all f (src(f)=E <-> f=E).
all f (tgt(f)=E <-> f=E).

% composition, src, tgt --------------------
all f all g (f!=E & g!=E -> (src(g)=tgt(f) <-> (g*f != E))).
all f (tgt(src(f)) = src(f)).
all f (src(tgt(f)) = tgt(f)). % these imply src(src(f))=f & tgt(tgt(f))=f.
all f (f*src(f) = f).
all f (tgt(f)*f = f).
all f all g all h ((f*g)*h = f*(g*h)).

% convenience predicates ------------------
%((object(u) <-> (exists v (v!=E & tgt(v)=u)))).
%-object(E).

-object(E).
x!=E -> (x=src(x) <-> object(x)).

(u=E) | (endo(u) <-> src(u)=tgt(u)).
-endo(E).

%(u=E) | (iso(u) <-> (exists v ((v!=E) & object(v*u) & object(u*v)))).
%-iso(E).
%inv(E)=E.
%(u=E) | (v=E) | (u*v=E) | (v*u=E) |
%  ( (object(u*v)&object(v*u)) <-> (inv(u)=v & inv(v)=u) ).
%(u=E) | (inv(u)=E) | (object(u*inv(u)) & object(inv(u)*u)).
%(u=E) | (iso(u) <-> inv(u)!=E).

u=E | v=E | ((object(u*v) & object(v*u)) <-> (inv(u)=v & inv(v)=u)).
inv(E)=E.
u=E | v=E | (inv(u)=E -> (-object(u*v) | -object(v*u))).
u=E | (iso(u) <-> inv(u)!=E).

%(object(u) & object(v)) -> (
%    isomorphic(u,v) <-> (exists f (iso(f) & src(f)=u & tgt(f)=v))).

end_of_list. % ------------------------------


