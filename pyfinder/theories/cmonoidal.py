#!/usr/bin/env python

from pyfinder.expr import *

#______________________________________________________________________________
# 

"""
The simplest example is the monoid generated by $L$ and $P$ with $LPL=PLP$ and every element is idempotent. So it has order six, and is non-commutative. The six elements are $I, L, P, LP, PL$ and $LPL=PLP.$ The Bruhat order makes this monoid into a POSET, and is defined by "word inclusion", ie. $I \le L \le LP \le LPL=PLP$ etc. With this POSET structure we now have a (non-symmetric) monoidal category.

But I don't think there is any internal hom for this Bruhat monoid that makes it into a closed monoidal category, which is what we need for enrichment to work. So I think I'm stuck for now. 
"""

element = Sort('element')
rig = Sort('rig')

TOP = I = Constant(0, element)
L = Constant(1, element)
P = Constant(2, element)
LP = Constant(3, element)
PL = Constant(4, element)
BOT = PLP = LPL = Constant(5, element)

mul = Function('mul', [element, element], element)
hom = Function('hom', [element, element], element)
le = Function('le', [element, element], BOOL)

a = Variable('a', element)
b = Variable('b', element)
c = Variable('c', element)

monoidal = [
    mul(I, a) == a,
    mul(a, I) == a,
    mul(BOT, a) == BOT,
    mul(a, BOT) == BOT,
    mul(a, a) == a,
    mul(L, P) == LP,
    mul(P, L) == PL,
    mul(L, LP) == LP,
    mul(LP, P) == LP,
    mul(P, PL) == PL,
    mul(PL, L) == PL,
    mul(P, LP) == PLP,
    mul(L, PL) == LPL,
    mul(PL, P) == PLP,
    mul(LP, L) == LPL,
    mul(PL, LP) == BOT,
    mul(LP, PL) == BOT]

poset = [
    le(a, a),
    le(a, BOT), le(I, a), # Bruhat order
    le(mul(b, c), a).implies(le(b, a) & le(c, a)),
    le(L, PL),
    le(L, LP),
    le(P, PL),
    le(P, LP),
    ~le(P, L),
    ~le(L, P),
    ~le(LP, PL),
    ~le(PL, LP),
    (le(a, b) & le(b, a)).implies(a==b),
] # 1 model

poset = [
    le(a, a),
    le(BOT, a), le(a, I), # Bruhat order
    #le(mul(b, c), a).implies(le(b, a) & le(c, a)),
    le(PL, L),
    le(LP, L),
    le(PL, P),
    le(LP, P),
    ~le(P, L),
    ~le(L, P),
    ~le(LP, PL),
    ~le(PL, LP),
    (le(a, b) & le(b, a)).implies(a==b),
] # 1 model

closed = [
    le(mul(hom(a, b), hom(b, c)), hom(a, c)),
    #le(hom(a, c), mul(hom(a, b), hom(b, c))),
    #le(b, hom(a, c)) == le(mul(a, b), c) # tensor-hom adjunction
#    le(a, hom(b, c)) == le(mul(a, b), c) # tensor-hom adjunction
    le(hom(b, c), a) == le(c, mul(a, b)) # tensor-hom adjunction
]

if 1:

    theory = Theory(monoidal + closed)
    sorts = [element]
    funcs = [mul, hom]


elif 1:
    theory = Theory(monoidal + poset + closed)
    sorts = [element]
    funcs = [mul, le, hom]

else:

    theory = Theory(monoidal + poset)
    sorts = [element]
    funcs = [mul, le]

